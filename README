Christian Delozier <delozier>, Zi Yan <yanzi>

*Overview
  Our project is a modifcation of HARM in Hackage. It is a simple simulator 
  which can run simplified ARM assembly language. And it supports some basic
  swi (software interruption), including reading keyboard, writing to screen.
  
  The workflow of our program is following: it 1) reads an assembly language
  file from disk, 2) translates it into internal Program data structure, 
  3) encode the Program data structure as binary code into Memory component 
  in the simulator, and 4) runs the loaded program as a real machine by 
  reading and writing Memory as well as receiving input from the keyboard, 
  printing output on the screen. 
  
  Additionally, the program supports a debug mode in which user can run the 
  program one instruction by another and check the contents of Register and 
  Memory.
  
  In CPU, Register, and Memory modules, you can see the fundamental structure 
  of our simulator. In Register modules, all operations that read and write 
  registers are there. In Memory modules, functions there perform the access 
  in both Cache and MemData. In CPU modules, all the operations in Register 
  and Memory are gathered as a whole to be invoke and to interplay with each 
  other. Any effect caused by executing an instruction will be brought into 
  CPU via writing to Registers or Memory. We also provide an alternate CPU
  prototype without cache to show the extensiblity of our design.
  
  In ExecutionUnit module, each instruction is interpreted separately and 
  change the CPU state correspondingly. eval is in charge of single-cycle 
  program execution, whereas evalIO is in charge of in-order pipeline 
  execution.
  
  In Stage module, we simulate an instruction will be executed in a sequence
  of Stages, including fetch, decode, execute, memRead, and memWrite. In order
  to simulate, the Stages are executed in reverse order. And the Auxilary
  data structure in CPU helps record the changes after each Stage. 
  
  We reuse the rest of modules from HARM, like Assembler, BinaryNumber, 
  Decoder, Encoder, Format, Instruction, Loader, Operand, ParseLib, Parser,
  Program, RegisterName, and Swi. Among these, we remove some unnecassary
  instructions from Assembler and Instruction, and modify Debugger, Loader, 
  Swi in order to conform to the new State Monad design.
